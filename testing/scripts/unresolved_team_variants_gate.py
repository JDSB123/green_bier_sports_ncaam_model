#!/usr/bin/env python3
"""
Hard gate for unresolved team variants.

Input: manifests/unresolved_team_variants.json (generated by
testing/scripts/generate_merge_quality_reports.py).

Default policy (tunable via CLI):
  - Require 0 unresolved variants for authoritative non-score sources:
    odds_api, barttorvik_ratings, ncaahoopr
  - Allow a bounded number of unresolved variants for scores (usually non-D1),
    but fail if it grows beyond the configured threshold.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any, Dict


ROOT = Path(__file__).resolve().parents[2]


def _load_json(path: Path) -> Dict[str, Any]:
    data = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(data, dict):
        raise ValueError("report is not a JSON object")
    return data


def main() -> int:
    parser = argparse.ArgumentParser(description="Fail if unresolved team variants exceed thresholds")
    parser.add_argument(
        "--report",
        type=Path,
        default=ROOT / "manifests" / "unresolved_team_variants.json",
        help="Path to unresolved_team_variants.json",
    )
    parser.add_argument(
        "--max-unresolved-scores",
        type=int,
        default=100,
        help="Max unresolved variants allowed for score sources (scores_fg/scores_h1)",
    )
    parser.add_argument(
        "--require-zero",
        nargs="*",
        default=["odds_api", "barttorvik_ratings", "ncaahoopr"],
        help="Sources that must have 0 unresolved variants",
    )
    args = parser.parse_args()

    report_path: Path = args.report
    if not report_path.is_absolute():
        report_path = (ROOT / report_path).resolve()
    if not report_path.exists():
        raise SystemExit(f"[FAIL] report not found: {report_path}")

    data = _load_json(report_path)
    totals = data.get("totals_by_source", {})
    if not isinstance(totals, dict):
        raise SystemExit("[FAIL] totals_by_source missing/invalid")

    failures = []

    # Require-zero sources
    for source in args.require_zero:
        s = totals.get(source, {})
        unresolved = int(s.get("unresolved", 0)) if isinstance(s, dict) else 0
        if unresolved != 0:
            failures.append(f"{source}: unresolved={unresolved} (expected 0)")

    # Scores sources (bounded)
    for source in ["scores_fg", "scores_h1"]:
        s = totals.get(source, {})
        unresolved = int(s.get("unresolved", 0)) if isinstance(s, dict) else 0
        if unresolved > int(args.max_unresolved_scores):
            failures.append(
                f"{source}: unresolved={unresolved} > max_unresolved_scores={args.max_unresolved_scores}"
            )

    if failures:
        print("[FAIL] Unresolved team variant gate failed:")
        for f in failures:
            print(f"  - {f}")
        return 1

    print("[OK] Unresolved team variant gate passed")
    for source, s in sorted(totals.items()):
        if not isinstance(s, dict):
            continue
        print(
            f"  - {source}: seen={int(s.get('seen', 0))} "
            f"resolved={int(s.get('resolved', 0))} "
            f"unresolved={int(s.get('unresolved', 0))}"
        )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

